
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>(todo) Compared to Other Systems Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.1.0">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../api-spec-generated/overview.html" />
    
    
    <link rel="prev" href="clients.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../getting-started.html">
            
                <a href="../getting-started.html">
            
                    
                    Getting Started
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../using.html">
            
                <a href="../using.html">
            
                    
                    Using Nakadi
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="concepts.html">
            
                <a href="concepts.html">
            
                    
                    Concepts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="event-types.html">
            
                <a href="event-types.html">
            
                    
                    Event Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="producing-events.html">
            
                <a href="producing-events.html">
            
                    
                    Producing Events
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="consuming-events.html">
            
                <a href="consuming-events.html">
            
                    
                    Consuming Events
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="clients.html">
            
                <a href="clients.html">
            
                    
                    Client Libraries
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.6" data-path="comparison.html">
            
                <a href="comparison.html">
            
                    
                    (todo) Compared to Other Systems
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../api-spec-generated/overview.html">
            
                <a href="../api-spec-generated/overview.html">
            
                    
                    API Reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../api-spec-generated/paths.html">
            
                <a href="../api-spec-generated/paths.html">
            
                    
                    Paths
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../api-spec-generated/definitions.html">
            
                <a href="../api-spec-generated/definitions.html">
            
                    
                    Definitions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../api-spec-generated/security.html">
            
                <a href="../api-spec-generated/security.html">
            
                    
                    Security
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../developing.html">
            
                <a href="../developing.html">
            
                    
                    Building and Developing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../operating.html">
            
                <a href="../operating.html">
            
                    
                    (todo) Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../recipes.html">
            
                <a href="../recipes.html">
            
                    
                    (todo) Recipes and Patterns
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../faq.html">
            
                <a href="../faq.html">
            
                    
                    (partial) FAQ
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >(todo) Compared to Other Systems</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="comparison-to-other-systems"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>Comparison to Other Systems</h2>
<p>In this section, we&apos;ll look at how Nakadi fits in with the stream broker/processing ecosystems. Notably we&apos;ll compare it to Apache Kafka, as that&apos;s a common question, but also look briefly at some of the main cloud offerings in this area.</p>
<ul>
<li><a href="#kafka">Apache Kafka</a></li>
<li><a href="#pubsub">Google Pub/Sub</a></li>
<li><a href="#kinesis">AWS Kinesis</a></li>
<li><a href="#eventhub">Azure EventHub</a></li>
<li><a href="#confluent">Confluent Platform</a></li>
</ul>
<p><a name="kafka"></a></p>
<h3 id="apache-kafka"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>Apache Kafka</h3>
<p>Relative to Apache Kafka, Nakadi provides a number of benefits while still leveraging the raw power of Kafka as its internal broker. </p>
<ul>
<li><p>Nakadi has some characteristics in common with Kafka, which is to be expected as the Kafka community has done an excellent job in defining the space. The logical model is basically the same - streams have partitions, messages in a partition maintain their order, and there&apos;s no order across partitions. One producer can send an event to be read by multiple consumers and consumers have access to offset data that they can checkpoint. There are also some differences. For example Nakadi doens&apos;t expose Topics as a concept in its API. Instead there are Event Types that define structure and ownership details as well as the stream. Also consumers receive messages in batches and each batch is checkpointed rather than an individual message.</p>
</li>
<li><p>Nakadi uses HTTP for communications. This lets microservices to maintain their boundaries and avoids forcing a shared technology dependency on producers and consumers - if you can speak HTTP you can use Nakadi and communicate with other services. This is a fairly subtle point, but Nakadi is optimised for general microservices integration and message passing, and not just handing off data to analytics subsystems. This means it needs to be available to as many different runtimes and stacks as possible, hence HTTP becomes the de-facto choice.</p>
</li>
<li><p>Nakadi is designed to support autonomous service teams. In Zalando, where Nakadi originated, each team has autonomy and control of their microservices stack to let them move quickly and take ownership. When running on AWS, this extends all the way down - every team has their own account structure, and to ensure a level of security and compliance teams run standard AMIs and constrain how they interact to HTTPS using OAuth2 access controls. This means we tend to want to run any shared infrastructure as a service with a HTTP based interface. Granted, not everyone has this need - many shops on AWS won&apos;t have per-team account structures and will tend to use a smaller number of shared environments, but we&apos;ve found it valulable to be able leverage the power of systems like Kafka in a way that fits in with this service architecture. </p>
</li>
<li><p>An event type registry with schema validation. Producers can define event types using JSON Schema. Having events validated against a published schema allows consumers to know they will.  There are projects in the Kafka ecosystem from Confluent that provide similar features such as the rest-proxy and the schema-registry, but they&apos;re slightly optimised for analytics, and not quite ideal for microservices where its more common to use regular JSON rather than Avro. The schema registry in particular is dependent on Avro. Also the consumer connection model for the rest-proxy requires clients are pinned to servers which complicates clients - the hope for the Nakadi is that its managed susbcription API, when that&apos;s available, will not require session affinity in this way.</p>
</li>
<li><p>Inbuilt event types. Nakadi also optional support for events that describe business processes and data changes. These provide common primitives for event identity, timestamps, causality, operations on data and header propagation. Teams could define their own structures, but there&apos;s value in having some basic things that consumers and producers can coordinate on independent of the payload, and which are being checked before being propagated to multiple consumers.</p>
</li>
<li><p>Operations is also a factor in Nakadi&apos;s design. Managing upgrades to systems like Kafka becomes easier when technology sits behind an API and isn&apos;t a shared dependency between microservices. Asychronous event delivery can be a simpler overall option for a microservice architecture compared to synchronized and deep call paths that have to be mitigated with caches, bulkheads and circuit breakers.</p>
</li>
</ul>
<p>In short, Nakadi is best seen as a complement to Kafka. It allows teams to use Kafka within their own boundaries but not be forced into sharing it as a global dependency.</p>
<p><a name="pubsub"></a></p>
<h3 id="google-pubsub"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>Google Pub/Sub</h3>
<p>Like Nakadi, Pub/Sub has a HTTP API which hides details from producers and consumers and makes it suitable for use as a microservices backplane. There are some differences worth noting:</p>
<ul>
<li><p>Pub/Sub lets you acknowledge every message individually rather than checkpointing a position in a logical log. This approach makes its model fairly different to the other systems mentioned here. While it implies that there are no inbuilt ordering assurances it does allow consumers to be very precise about what they have received. </p>
</li>
<li><p>Pub/Sub requires a susbcription to be setup before messages can be consumed, which can then be used to manage delivery state for messages. In that sense it&apos;s not unlike a traditional queuing system where the server (or &quot;broker&quot;) manages state for the consumer, with the slight twist that messages have a sort of random access for acknowledgements instead of competing for work at the top of queue. Nakadi may offer a similar subcription option in the future via a managed API, but today consumers are expected to manage their own offsets.</p>
</li>
<li><p>Pub/Sub uses a polling model for consumers. Consumers grab a page of messages to process and acknowlege, and then make a new HTTP request to grab another page. Nakadi maintains a streaming connection to consumers, and will push events as they arrive.</p>
</li>
<li><p>Pub/Sub uses a common envelope structure for producing and consuming messages, and does not define any higher level structures beyond that.</p>
</li>
</ul>
<p><a name="kinesis"></a></p>
<h3 id="aws-kinesis"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>AWS Kinesis</h3>
<p>Like Nakadi and Pub/Sub, AWS Kinesis has a HTTP API to hide its details. Kinesis and Nakadi are more similar to each other than Pub/Sub, but there are some differences.</p>
<ul>
<li><p>Kinesis expose shards (partitions) for a stream and supplies enough information to support per message checkpointing with semantics much like Kafka and Nakadi. Nakadi only supplies checkpointing information per batch of messages. Kinesis allows setting the partition hash key directly, whereas Nakadi computes the key based on the data. </p>
</li>
<li><p>Kinesis uses a polling model for consumers, whereas Nakadi maintains a streaming connection Kinesis consumers use a &quot;shard iterator&quot; to a grab pages of message, and then make a new HTTP request to grab another page. Kinesis limits the rate at which this can be done across all consumers (typically 5 transactions per second per open shard), which places an upper bound on consumer throughput. Kinesis has a broad range of choices for resuming from a position in the stream, Nakadi allows access only from the beginning and a named offset.</p>
</li>
<li><p>Kinesis uses a common envelope structure for producing and consuming messages, and does not define any higher level structures beyond that. Payload data is submitted as an opaque base64 blob.</p>
</li>
<li><p>AWS restrict the number of streams available to an account to quite a low starting number, and messages can be stored for a maximum of 7 days whereas Nakadi can support a large number of event types and the expiration for events is configurable.</p>
</li>
<li><p>Kinesis supports resizing the number of shards in a stream wheres partition counts in Nakadi are fixed once set for an event type.</p>
</li>
</ul>
<p><a name="eventhub"></a></p>
<h3 id="azure-event-hub"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>Azure Event Hub</h3>
<p><em>@@@ todo</em></p>
<p><a name="confluent"></a></p>
<h3 id="confluent-platform"><a name="undefined" class="plugin-anchor" href="#undefined"><span class="fa fa-link"></span></a>Confluent Platform</h3>
<p><em>@@@ todo</em></p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="clients.html" class="navigation navigation-prev " aria-label="Previous page: Client Libraries">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../api-spec-generated/overview.html" class="navigation navigation-next " aria-label="Next page: API Reference">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"(todo) Compared to Other Systems","level":"1.3.6","depth":2,"next":{"title":"API Reference","level":"1.4","depth":1,"path":"docs/api-spec-generated/overview.md","ref":"docs/api-spec-generated/overview.md","articles":[{"title":"Paths","level":"1.4.1","depth":2,"path":"docs/api-spec-generated/paths.md","ref":"docs/api-spec-generated/paths.md","articles":[]},{"title":"Definitions","level":"1.4.2","depth":2,"path":"docs/api-spec-generated/definitions.md","ref":"docs/api-spec-generated/definitions.md","articles":[]},{"title":"Security","level":"1.4.3","depth":2,"path":"docs/api-spec-generated/security.md","ref":"docs/api-spec-generated/security.md","articles":[]}]},"previous":{"title":"Client Libraries","level":"1.3.5","depth":2,"path":"docs/using/clients.md","ref":"docs/using/clients.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["-sharing","-search","-highlight","anchors"],"pluginsConfig":{"anchors":{},"lunr":{"maxIndexSize":1000000},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/using/comparison.md","mtime":"2016-06-09T13:38:53.272Z","type":"markdown"},"gitbook":{"version":"3.1.0","time":"2016-06-09T13:40:13.761Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

